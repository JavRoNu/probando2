<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Javier Kniffki" />
<meta name="author" content="javierkniffki@gmail.com" />

<meta name="date" content="2021-12-16" />

<title>Guía-Introducción</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Curso R CCPP 2021</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="intro_basica.html">Primera sesión</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Segunda sesion
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="borrar.html">Segunda sesión</a>
    </li>
    <li>
      <a href="regresion_1.html">Ejercicios segunda sesión</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Guía-Introducción</h1>
<h3 class="subtitle">Introducción a R. Ciencias Políticas</h3>
<h4 class="author">Javier Kniffki</h4>
<h4 class="author"><a href="mailto:javierkniffki@gmail.com" class="email">javierkniffki@gmail.com</a></h4>
<h4 class="date">2021-12-16</h4>

</div>


<!-- <script> -->
<!--    $(document).ready(function() { -->
<!--      $head = $('#header'); -->
<!--      $head.prepend('<img src=\"kstats.png\" style=\"float: right;width: 150px;\"/>') -->
<!--    }); -->
<!-- </script> -->
<div id="qué-es-r" class="section level2">
<h2>¿Qué es R?</h2>
<p>R es un entorno de programación orientado al análisis estadístico, flexible y con multitud de librerías, muy utilizado para el análisis de datos científicos. Es Software Libre y se distribuye bajo licencia GPL.</p>
</div>
<div id="porqué-utilizar-r" class="section level2">
<h2>¿Porqué utilizar R?</h2>
<p>“El software libre es un tipo de programas de ordenador que una vez obtenidos pueden ser usados, copiados, estudiados, modificados y redistribuidos libremente. Estos permisos son otorgados por sus autores, o quién sea que ostente los derechos de propiedad intelectual sobre el producto, a través de un acuerdo de licencia —una forma de contrato— que acompaña a cualquier programa.</p>
<p>De forma más precisa, el software libre es aquel cuya licencia ofrece a los usuarios las siguientes cuatro libertades:</p>
<ul>
<li>La libertad de usar el programa, con cualquier propósito. (libertad 0)</li>
<li>La libertad de estudiar cómo funciona el programa, y adaptarlo a tus necesidades. (libertad 1)</li>
<li>La libertad de distribuir copias, con lo que puedes ayudar a tu vecino. (libertad 2)</li>
<li>La libertad de mejorar el programa y hacer públicas las mejoras a los demás, de modo que toda la comunidad se beneficie. (libertad 3)</li>
</ul>
<p>Para que las libertades 1 y 3 sean posibles es necesario que los usuarios puedan tener acceso al código fuente de los programas. Este código fuente es el conjunto de líneas de texto que indican las instrucciones que debe seguir el ordenador para ejecutar dicho programa. Es decir, en el código fuente de un programa está escrito por completo su funcionamiento. Así que tener acceso a él es la única forma de poder estudiarlo y modificarlo con garantías.</p>
<p>Si hemos estado atentos a todo lo que hemos comentado, rápidamente nos daremos cuenta de que no hemos hecho ninguna referencia al precio de los programas. De hecho, debemos tener presente que aunque mucho software libre es gratuito, esto no tiene por qué ser necesariamente así. La libertad del software está relacionada con los permisos que su autor ofrece y no con su precio.”<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>Además, existen planteamientos éticos sobre la idoneidad de utilizar software libre en la universidad pública frente al SW comercial.</p>
<p>Dentro de los lenguajes de programación orientados al análisis de datos destaca también el lenguaje Python. Existe un amplio debate acerca de cuál es el más adecuado para las distintas tareas que implican estos procesos. En términos generales R se emplea más para el análisis estadístico ad hoc y en ámbitos académicos, mientras que Python se desenvuelve mejor dentro del desarrollo, de ello su integración en la empresa privada.</p>
<p>Por último es importante resaltar el carácter polifacético que tiene R. Y es que este se encuentra a medio camino entre un lenguaje de programación y un entorno de comando para el análisis estadístico. Quizás esta flexibilidad sea uno de los aspectos más destacables ya que permite diferentes usos o formas de trabajar con R. Podemos optar por el análisis directo y secuencial en la línea de comandos o con apoyo de un presentando los resultados en látex o automatizar y adaptar procesos mediante control de flujo, funciones y otros elementos más puros programación.</p>
<div id="jornadas-y-comunidades" class="section level3">
<h3>Jornadas y comunidades</h3>
<p>Jornadas España: <a href="http://r-es.org/XjuR/" class="uri">http://r-es.org/XjuR/</a></p>
<p>Jornadas Usuarios R en Galicia: <a href="https://www.r-users.gal/" class="uri">https://www.r-users.gal/</a></p>
<p>Comunidad ROpenSpain: <a href="https://ropenspain.es/" class="uri">https://ropenspain.es/</a></p>
<p>Comunidad de habla hispana: <a href="http://r-es.org/" class="uri">http://r-es.org/</a></p>
<p>Diversidad de género en la comunidad R (listado de comunidades por países):</p>
<p><a href="https://rladies.org/" class="uri">https://rladies.org/</a></p>
<p>Blog r-bloggers:</p>
<p><a href="https://www.r-bloggers.com/" class="uri">https://www.r-bloggers.com/</a></p>
<p>…</p>
</div>
</div>
<div id="instalación-y-configuración-de-r-y-r-studio" class="section level2">
<h2>Instalación y configuración de R y R-Studio</h2>
<div id="páginas-de-descarga" class="section level3">
<h3>Páginas de descarga:</h3>
<ul>
<li><a href="https://www.r-project.org/" class="uri">https://www.r-project.org/</a></li>
<li><a href="https://www.rstudio.com/" class="uri">https://www.rstudio.com/</a></li>
</ul>
<p>La utilización del editor R-Studio presenta ventajas que no encontramos en R; por ejemplo comprobar que ningún paréntesis se queda sin cerrar, copiar y completar columnas, autocompletado, lista de variables, descripción del banco de datos, paquetes instalados, gráficos…</p>
</div>
<div id="alternativas-en-linea" class="section level3">
<h3>Alternativas en linea</h3>
<p>Si no queremos instalar R en nuestro ordenador o/y trabajamos en múltiples computadoras y necesitamos usar R tenemos las siguientes alternativas:</p>
<ul>
<li><a href="https://www.rstudio.com/products/cloud/" class="uri">https://www.rstudio.com/products/cloud/</a></li>
</ul>
<p>En Rstudio cloud tras registrarnos la versión gratiutia nos deja 25h mensuales y</p>
<ul>
<li><a href="https://www.kaggle.com/" class="uri">https://www.kaggle.com/</a></li>
</ul>
</div>
</div>
<div id="consola-script-y-buenas-prácticas" class="section level2">
<h2>Consola, script y buenas prácticas</h2>
<p>A continuación se presentan algunas guías de estilo que pueden ser encontradas fácilmente en la red.</p>
<ul>
<li><p><a href="https://google.github.io/styleguide/Rguide.xml" class="uri">https://google.github.io/styleguide/Rguide.xml</a></p></li>
<li><p><a href="http://adv-r.had.co.nz/Style.html" class="uri">http://adv-r.had.co.nz/Style.html</a></p></li>
</ul>
<p>Seguiremos unos principios básicos a la hora de escribir código:</p>
<ul>
<li>Comenta tu código. Hoy sabes lo que hiciste, dentro de un mes no y desde luego tus colaboradores tampoco.</li>
<li>Respeta los espacios.</li>
<li>Tabulación por lo menos de 8 puntos.</li>
<li>No más de 80 caracteres por línea (respira).</li>
<li>No te vuelvas loco/a creando objetos. R es dinámico.</li>
<li>Dales un nombre apropiado a tus objetos.</li>
<li>No compartas código con sentencias relativas a tu ordenador.</li>
</ul>
<p>Mal:</p>
<pre class="r"><code>migraficademediacondionada=plot(sr~ind,type=&quot;n&quot;,xaxt=&quot;n&quot;,xlab=&quot;&quot;,ylab=&quot;&quot;,main=&quot;IC media&quot;);points(ICm[,1]~ind,pch=16);segments(ind,ICm[,2],ind,ICm[,3])</code></pre>
<p>Mejor:</p>
<pre class="r"><code># Intervalos para la media condicionada
m.cond &lt;- plot(sr ~ ind, type = &quot;n&quot;, xaxt = &quot;n&quot;, 
               xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;IC media&quot;)
#Puntos
points(ICm[, 1] ~ ind, pch = 16)
#Segmentos
segments(ind, ICm[, 2], ind, ICm[, 3])</code></pre>
</div>
<div id="pedir-ayuda-e-instalción-de-paquetes" class="section level2">
<h2>Pedir ayuda e instalción de paquetes</h2>
<div id="pedir-ayuda" class="section level3">
<h3>Pedir ayuda</h3>
<p>En Internet:</p>
<ul>
<li><p>Comunidad stackoverflow <a href="https://stackoverflow.com/" class="uri">https://stackoverflow.com/</a></p></li>
<li><p>Google</p></li>
<li><p>Mailing List <a href="https://www.r-project.org/mail.html" class="uri">https://www.r-project.org/mail.html</a></p></li>
</ul>
<p>En R:</p>
<pre class="r"><code>help.search()
help()
?función
help.start() #Ayuda en Htlm </code></pre>
<p>Encontrar librerías destacadas en CRAN:</p>
<p><a href="https://cran.r-project.org/web/views/" class="uri">https://cran.r-project.org/web/views/</a></p>
<p>Librerías Genomic-data:</p>
<p><a href="https://www.bioconductor.org/" class="uri">https://www.bioconductor.org/</a></p>
<p>Cheatsheets:</p>
<p><a href="https://www.rstudio.com/resources/cheatsheets/" class="uri">https://www.rstudio.com/resources/cheatsheets/</a></p>
</div>
<div id="bibliografía" class="section level3">
<h3>Bibliografía</h3>
<p>Monogan, J. E. (2015). Political analysis using R. Springer.</p>
<p>Murrell, P. (2009). R Graphics. Wiley Interdisciplinary Reviews: Computational Statistics, 1(2), 216-220.</p>
<p>Peng, R. (2012). Exploratory data analysis with R</p>
<p>Verzani, J. (2014). Using R for introductory statistics CRC Press.</p>
<p>Williams, G. J. (2017). The Essentials of Data Science: Knowledge Discovery Using R Chapman and Hall/CRC.</p>
<p>Wickham, H. (2016). ggplot2: elegant graphics for data analysis. Springer.</p>
<p>Imai, K. (2017). Quantitative social science: An introduction. Princeton University Press.</p>
</div>
<div id="identificamos-el-entorno-rstudio" class="section level3">
<h3>Identificamos el entorno Rstudio</h3>
<p>Información de la sesión:</p>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 4.1.2 (2021-11-01)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 19043)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=Spanish_Spain.1252  LC_CTYPE=Spanish_Spain.1252    LC_MONETARY=Spanish_Spain.1252 LC_NUMERIC=C                  
## [5] LC_TIME=Spanish_Spain.1252    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] dplyr_1.0.7    Amelia_1.8.0   Rcpp_1.0.7     foreign_0.8-81
## 
## loaded via a namespace (and not attached):
##  [1] pillar_1.6.4     bslib_0.3.1      compiler_4.1.2   jquerylib_0.1.4  highr_0.9        tools_4.1.2      digest_0.6.29   
##  [8] jsonlite_1.7.2   evaluate_0.14    lifecycle_1.0.1  tibble_3.1.6     pkgconfig_2.0.3  rlang_0.4.12     DBI_1.1.1       
## [15] cli_3.1.0        rstudioapi_0.13  yaml_2.2.1       xfun_0.28        fastmap_1.1.0    stringr_1.4.0    knitr_1.36      
## [22] generics_0.1.1   vctrs_0.3.8      sass_0.4.0       tidyselect_1.1.1 glue_1.5.1       R6_2.5.1         fansi_0.5.0     
## [29] rmarkdown_2.11   purrr_0.3.4      tidyr_1.1.4      magrittr_2.0.1   backports_1.3.0  ellipsis_0.3.2   htmltools_0.5.2 
## [36] assertthat_0.2.1 utf8_1.2.2       stringi_1.7.6    broom_0.7.10     crayon_1.4.2</code></pre>
</div>
<div id="instalación-de-paquetes" class="section level3">
<h3>Instalación de paquetes</h3>
<p>La función básica que utilizamos para instalar paquetes en nuestro equipo es <code>install.packages("nombre_del_paquete")</code>. Otra manera es utilizar los menús desplegables de RStudio.</p>
<pre class="r"><code>install.packages(&quot;Nombre_del_paquete&quot;)</code></pre>
<p>Una vez que instalamos un paquete no tendremos que volver a instalarlo. Lo que sí tenemos que hacer es cargarlo en cada sesión para poder utilizar sus funciones. Esto lo hacemos con <code>library("paquete")</code> que suele ponerse al inicio de nuestro script.</p>
<p>En la actualidad existen más de 15000 librerías en el repositorio CRAN.</p>
</div>
</div>
<div id="r-una-super-calculadora" class="section level2">
<h2>R una super calculadora</h2>
<p><strong>Operaciones aritméticas</strong></p>
<p>Algunas de las siguientes funciones se pueden aplicar para números, vectores y matrices.</p>
<pre class="r"><code>x + y # suma 
x - y   # resta 
x * y   # producto 
x / y   # cociente 
x ^ y   # potencia
x ** y  # potencia 
x %% y  # x módulo  y
x %/% y   # división entera (parte entera del cociente)</code></pre>
<p><strong>Funciones numéricas</strong></p>
<pre class="r"><code>abs(x)  # valor absoluto 
sqrt(x) # raíz cuadrada 
ceiling(x) # |x| entero mayor o igual a x más pequeño 
floor(x) # |x| entero menor o igual a x más grande 
trunc(x) #parte entera de x 
sin(x) #seno 
cos(x) #coseno 
tan(x) #tangente 
log(x) #logaritmo en base e 
log(x, base=a) #logaritmo en base a 
exp(x) #exponencial 
factorial(x) #factorial 
max(x,y) #máximo 
min(x,y) #mínimo</code></pre>
<p><strong>Constantes</strong></p>
<ul>
<li><p>pi <span class="math inline">\(\pi\)</span> (3.141593…)</p></li>
<li><p>exp(1) <span class="math inline">\(e\)</span> (2.718282…)</p></li>
<li><p>library(constants) Podemos encontrar más constantes universales.</p></li>
</ul>
<p><strong>Operadores lógicos</strong></p>
<pre class="r"><code>x &lt; y # menor que 
x &gt; y # mayor que 
x &lt;= y # menor o igual a 
x &gt;= y # mayor o igual a 
x == y # igual a 
x != y # distinto a
x &amp; y # y 
x | y # o 
!x # negación de x</code></pre>
<p><strong>Pregunta if</strong></p>
<p>La estructura general es:</p>
<pre class="r"><code>if (condición) { expresión } 

#Por ejemplo, 
if (x &gt;= 0) { cat(&quot;El valor de x es mayor o igual a cero.\n&quot;) }</code></pre>
<p><strong>Pregunta if-else</strong></p>
<p>La estructura general es:</p>
<pre class="r"><code>if (condición) { 
        expresión1 
} else {
        expresión2 
} 
#Por ejemplo, 
if (x&gt;=0) { 
        cat(&quot;El valor de x es mayor o igual a cero.\n&quot;) 
} else { 
        cat(&quot;El valor de x es negativo.\n&quot;) 
        }</code></pre>
<p><strong>Ciclo for</strong></p>
<hr />
<p><font color = "green"><em>Existe una familia de funciones “apply” que funcionan como los ‘for loops’ cuando estos recorren una matriz de datos o listas (ver objetos más adelante). Resultan más comodas para realizar ciertas operaciones que los for loops y además forman parte del lenguaje “natural” de R.</em> </font></p>
<hr />
<p>La estructura general es:</p>
<pre class="r"><code>for (variable in secuencia) { expresión } 

#Por ejemplo, 
for (x in 1:3) { 
        cat(&quot;x es&quot;, x, &quot;\n&quot;) 
        } </code></pre>
<p><strong>Ciclo while</strong></p>
<p>La estructura general es:</p>
<pre class="r"><code>while (condición) { expresión } 

#Por ejemplo, 
x &lt;- 0 
while (x&lt;3) { 
        cat(&quot;x es&quot;, x, &quot;\n&quot;) 
        x &lt;- x+1 } 
cat(&quot;x ya es&quot;, x, &quot;\n&quot;) </code></pre>
<p><strong>Matrices</strong></p>
<pre class="r"><code>matrix #Deﬁnición de matrices en R 
t(A)   # Matriz traspuesta 
A * B  # Multiplicación de matrices elemento a elemento 
A %*% B # Producto matricial 
A %o% B # Producto exterior 
crossprod(A,B) #Producto A&#39;B 
crossprod(A)   #Producto A&#39;A 
diag(x)        #Si x es un vector, crea una matriz diagonal con los elementos de x en la diagonal 
diag(A) # Si A es una matriz, devuelve la diagonal de A 
diag(k) # Si k es un escalar, devuelve la matriz Identidad de dimensión k 
solve(A, b) # Devuelve el vector x, solución de Ax = b
solve(A)  # Inversa de la matriz A 
y &lt;- eigen(A) # Cálculo de autovalores y autovectores de A 
y$val    # Autovalores de A 
y$vec    # Autovectores de A 
U &lt;- chol(A) # Descomposición de Choleski de A. Devuelve una matriz triangular superior U tal que U&#39;U = A
cbind(A,B,...)  # Combina matrices o vectores horizontalmente 
rbind(A,B,...)  # Combina matrices o vectores verticalmente 
rowMeans(A) # Vector de medias por ﬁlas 
rowSums(A) # Vector de suma de ﬁlas 
colMeans(A) # Vector de medias por columnas 
colSums(A) # Vector de suma de columnas 
apply(A,1,fun) # Aplica la función fun a cada ﬁla de la matriz A 
apply(A,2,fun) # Aplica la función fun a cada columna de la matriz A</code></pre>
</div>
<div id="datos-bien-estructurados" class="section level2">
<h2>Datos bien estructurados</h2>
<p>Filosofía:</p>
<p><a href="https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html" class="uri">https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html</a></p>
<p>Existen muchas librerías que ayudan a estructurar correctamente los datos. Una de las mas utilizadas es el paquete <code>tydir</code> del universo <code>tidyverse</code> que combinada con el manejo de cadenas (strings) da buenos resultados. (ver Cheatsheet “String manipulation”)</p>
</div>
<div id="tipos-de-objetos" class="section level2">
<h2>Tipos de objetos</h2>
<hr />
<p><strong>Case sensitivity</strong></p>
<p><em>R es “sensible” a las mayúsculas y minúsculas; <code>A</code> y <code>a</code> se refieren a diferentes objetos. Además si una sentencia está incompleta al final de una línea R pedirá mas información devolviendo el símbolo <code>+</code>.<font color="green"> Tip: Nombra a todos tus objetos en minúsculas y sin acentos.</em></font></p>
<hr />
<p>La estructura fundamental del lenguaje R es el vector.</p>
<p>Entre los principales objetos y más comunes encontraremos:</p>
<ul>
<li>Vector</li>
<li>Matriz</li>
<li>Arrays (elementos del mismo tipo)</li>
<li>Factores</li>
<li>Caractér</li>
<li>Numericos (double)</li>
<li>Lógicos</li>
<li>Listas</li>
<li>Data frame</li>
<li>Funciones</li>
<li>…</li>
</ul>
<p>¿Cómo sabemos de que clase es un objeto?</p>
<pre class="r"><code>class()</code></pre>
<p><strong>Vector</strong></p>
<p>Es la estructura básica de las variables. Los vectores (y otros objetos) se crean utilizando el operador de asignación <code>&lt;-</code> o <code>=</code> que asigna la operación evaluada del lado derecho del operador al objeto del lado izquierdo.</p>
<pre class="r"><code>x &lt;- c(5, 7, 9, 13, -4, 8) # Preferente 
x = c(5, 7, 9, 13, -4, 8) # Equivalente
x #llamar objeto</code></pre>
<pre><code>## [1]  5  7  9 13 -4  8</code></pre>
<p>Tres funciones útiles son:</p>
<ul>
<li><code>exist()</code> Nos indica si un objeto existe en el espacio de trabajo.</li>
<li><code>rm()</code> Elimina objetos del espacio de trabajo.</li>
<li><code>ls()</code> Lista los objetos que existen en el entorno.</li>
</ul>
<p>De la misma manera podemos crear distintos objetos e incluso coercionar objetos de un tipo a otro.</p>
<p><strong>Matriz</strong></p>
<p>Las matrices almacenan valores en colecciones (arrays) bi-dimensionales que contienen elementos del mismo tipo, tal cual como una matriz en el contexto del álgebra lineal. Para crear una matriz tenemos que “pasar” un vector atómico (elementos del mismo tipo). Después le indicamos el número de filas y/o columnas con el argumento <code>nrow = un número</code> o <code>ncol = un número</code> respectivamente.</p>
<pre class="r"><code>dado &lt;- c(1:6)
m &lt;- matrix(dado, nrow = 2)
m</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6</code></pre>
<p>Fijémonos en como posiciona los números por defecto. Si queremos que los indexe fila por fila, utilizamos el argumento lógico <code>byrow = TRUE</code>.</p>
<pre class="r"><code>m &lt;- matrix(dado, nrow = 2, byrow = TRUE)
m</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6</code></pre>
<p><strong>Arrays</strong></p>
<p>Es como la matriz pero n-dimensional y menos versátil. Podemos usar un array para indexar valores en un cubo o hipercubo de 4,5, n-dimensiones. Para utilizarlo le pasamos un vector atómico como primer argumento y después las dimensiones con el argumento <code>dim</code>.</p>
<pre class="r"><code>coleccion &lt;- array(c(11:14, 21:24, 31:34), dim = c(2,2,3))
coleccion</code></pre>
<pre><code>## , , 1
## 
##      [,1] [,2]
## [1,]   11   13
## [2,]   12   14
## 
## , , 2
## 
##      [,1] [,2]
## [1,]   21   23
## [2,]   22   24
## 
## , , 3
## 
##      [,1] [,2]
## [1,]   31   33
## [2,]   32   34</code></pre>
<p><strong>Factores</strong></p>
<p>Se utilizan para almacenar valores categóricos, color de ojos, sexo, especie… Para crear un factor tenemos que pasar un vector atómico a la función <code>factor()</code>. De manera automática R añade niveles (un atributo. Ver atributos.) convirtiéndolos primero en enteros y asignando las etiquetas que corresponden a cada nivel (entero).</p>
<ul>
<li><code>class()</code> Nos devuelve el tipo de objeto.</li>
<li><code>attributes()</code> Nos devuelve los atributos del vector.</li>
</ul>
<pre class="r"><code>animales &lt;- factor(c(&quot;perro&quot;, &quot;gato&quot;, &quot;tortuga&quot;, &quot;tortuga&quot;))
animales</code></pre>
<pre><code>## [1] perro   gato    tortuga tortuga
## Levels: gato perro tortuga</code></pre>
<pre class="r"><code>class(animales)</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<pre class="r"><code>attributes(animales)</code></pre>
<pre><code>## $levels
## [1] &quot;gato&quot;    &quot;perro&quot;   &quot;tortuga&quot;
## 
## $class
## [1] &quot;factor&quot;</code></pre>
<p>Podemos ver como R sitúa exactamente los elementos con <code>unclass()</code></p>
<pre class="r"><code>unclass(animales)</code></pre>
<pre><code>## [1] 2 1 3 3
## attr(,&quot;levels&quot;)
## [1] &quot;gato&quot;    &quot;perro&quot;   &quot;tortuga&quot;</code></pre>
<p>Es importante no confundir los factores con los caracteres. En general es mejor impedir que R convierta automáticamente las cadenas de caracteres en factores (que lo intentará cuando cargamos y creamos datos) a menos de que vayamos a trabajar con datos categóricos.</p>
<p><strong>Caracteres</strong></p>
<p>Un vector tipo caracter está compuesto por cadenas de texto. Podemos crear un vector caracter con la función <code>character()</code> o bien añadiendo comillas.</p>
<pre class="r"><code>&quot;hola&quot;</code></pre>
<pre><code>## [1] &quot;hola&quot;</code></pre>
<pre class="r"><code>personas &lt;- c(&quot;María&quot;, &quot;Juan&quot;, &quot;Adelaida&quot;, &quot;Jorge&quot;)
personas</code></pre>
<pre><code>## [1] &quot;María&quot;    &quot;Juan&quot;     &quot;Adelaida&quot; &quot;Jorge&quot;</code></pre>
<pre class="r"><code>typeof(personas) #nos dice como se ha creado un objeto</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>A los elementos individuales de un vector caracter los llamamos <em>cadenas (strings)</em>. Nótese que un caracter puede ser más que letras. ¿Podrías determinar cuál de los siguientes elementos es un caracter y cuál es un número?</p>
<pre class="r"><code>1</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>&quot;1&quot;</code></pre>
<pre><code>## [1] &quot;1&quot;</code></pre>
<pre class="r"><code>&quot;uno&quot;</code></pre>
<pre><code>## [1] &quot;uno&quot;</code></pre>
<p>Un error muy típico es olvidar poner comillas a un caracter. Entonces R buscara un objeto en el entorno que probablemente no exista y nos devolverá un mensaje de error.</p>
<pre class="r"><code>class(1)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>class(&quot;1&quot;)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>Observemos una propiedad interesante de la función <code>character()</code> (numeric, logic…). Si vamos a la ayuda, observamos que admite el argumento <code>length</code> que por defecto es 0.</p>
<pre class="r"><code>caja &lt;- character(length = 5); caja </code></pre>
<pre><code>## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot;</code></pre>
<p>Nos devuelve 5 espacios en blanco, o dicho de otra manera, un vector de longitud 6 vacío. Esta propiedad que puede parecer una bagatela ¿Para qué habríamos de querer un vector vacío?, pues nos será de mucha ayuda a la hora de crear <em>loops</em>/ciclos y trabajar de manera iterativa.</p>
<ul>
<li><code>rep()</code> Replica los valores de <span class="math inline">\(x\)</span> <span class="math inline">\(n\)</span> veces.</li>
</ul>
<pre class="r"><code>caja &lt;- rep(&quot;hola&quot;, 4)
caja</code></pre>
<pre><code>## [1] &quot;hola&quot; &quot;hola&quot; &quot;hola&quot; &quot;hola&quot;</code></pre>
<p>Veámoslo ahora brevemente con el ciclo for (ver estructura ciclo for) y utilizando la función <code>numeric</code>.</p>
<pre class="r"><code>numeros &lt;- c(1,3,7,4,10)
numeros </code></pre>
<pre><code>## [1]  1  3  7  4 10</code></pre>
<pre class="r"><code>caja2 &lt;- numeric(length = length(numeros))
caja2</code></pre>
<pre><code>## [1] 0 0 0 0 0</code></pre>
<pre class="r"><code>for (i in seq_along(numeros)) {
        caja2[i] &lt;- i + 0.1
}
caja2</code></pre>
<pre><code>## [1] 1.1 2.1 3.1 4.1 5.1</code></pre>
<p>Observa que R ordena los elementos de menor a mayor automáticamente. Por el momento no importa si no entiendes muy bien lo que ha pasado antes. Durante el curso iremos practicando estos conceptos que nos serán de mucha utilidad en el futuro.</p>
<p><strong>Numéricos</strong></p>
<p>Es un vector de números. Positivos, negativos, con decimales o no. R guardará los números como <code>double</code> que es un término de computación referido a los bytes que utiliza el ordenador para computar. De cualquier manera, es mejor en nuestro caso pensar en ellos como simplemente números.</p>
<pre class="r"><code>numeros &lt;- c(1.3, 0.2, 4, 6, 0, -5); numeros</code></pre>
<pre><code>## [1]  1.3  0.2  4.0  6.0  0.0 -5.0</code></pre>
<pre class="r"><code>typeof(numeros)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<pre class="r"><code>class(numeros)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p>El objeto <code>numeros</code> ha sido creado como un <code>double</code>, sin embargo pertenece a la clase <code>numeric</code>. Números al fin y al cabo.</p>
<p><strong>Enteros</strong></p>
<p>Poco utilizados fuera de las ciencias de la computación. Nosotros podemos crear vectores simplemente de la manera que vimos en el anterior punto. No obstante, nos quedamos con la forma de crear explícitamente enteros (por si nos los encontramos por algún lado) que es con la letra <code>L</code> mayúscula.</p>
<ul>
<li><code>()</code> Encerramos la sentencia entre paréntesis para llamar al objeto automáticamente. No hay que abusar de esto pues nos podríamos confundir en un mar de paréntesis.</li>
</ul>
<pre class="r"><code>(enteros &lt;- c(-1L, 3L, -50L))</code></pre>
<pre><code>## [1]  -1   3 -50</code></pre>
<pre class="r"><code>typeof(enteros)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<p><strong>Lógicos</strong></p>
<p>Los vectores lógicos indexan verdaderos y falsos <code>TRUE</code>, <code>FALSE</code> de la forma booleana. Los operadores lógicos son de mucha ayuda para hacer comparaciones (ver operadores lógicos) y construir índices para extraer elementos que cumplan ciertas condiciones lógicas.</p>
<pre class="r"><code>10 &lt; 10.00001</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>1 == c(1,1,0,4,0,3) #no confundir &quot;=&quot; con &quot;==&quot;</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE FALSE FALSE FALSE</code></pre>
<p>Cada vez que tecleamos <code>TRUE</code> o <code>FALSE</code> o <code>F</code> o <code>V</code> R considera este input como un lógico. Por este motivo intentaremos evitar nombrar a nuestros objetos con estas letras.</p>
<pre class="r"><code>logico &lt;- c(TRUE, FALSE, TRUE, F); logico</code></pre>
<pre><code>## [1]  TRUE FALSE  TRUE FALSE</code></pre>
<p>En la anterior línea de código hemos utilizado <code>;</code> para concatenar sentencias en la misma línea.</p>
<p><strong>Ordinales</strong></p>
<p>Los ordinales son factores con un orden que dotanse a hallan categóricas, ampliamente empleados en las C.C.S.S.</p>
<pre class="r"><code>a &lt;- factor(c(&quot;bueno&quot;,&quot;regular&quot;,&quot;malo&quot;),ordered = T)
a</code></pre>
<pre><code>## [1] bueno   regular malo   
## Levels: bueno &lt; malo &lt; regular</code></pre>
<p>Vemos como en la declaración de los niveles aparaece el orden de menor a mayor de los niveles</p>
<p><strong>Listas</strong></p>
<p>Puede considerarse una lista como un vector atómico dado que agrupa elementos en conjuntos unidimensionales. Sin embargo, las listas no agrupan valores individuales sino objetos (que evidentemente pueden ser de diferente tipo) e incluso otras listas.</p>
<pre class="r"><code>milista &lt;- list(c(animales, 1:3, m, &quot;Perro&quot;, list(TRUE, FALSE)))
milista</code></pre>
<pre><code>## [[1]]
##  [1] &quot;2&quot;     &quot;1&quot;     &quot;3&quot;     &quot;3&quot;     &quot;1&quot;     &quot;2&quot;     &quot;3&quot;     &quot;1&quot;     &quot;4&quot;     &quot;2&quot;     &quot;5&quot;     &quot;3&quot;     &quot;6&quot;     &quot;Perro&quot; &quot;TRUE&quot;  &quot;FALSE&quot;</code></pre>
<p>Como ya se puede apreciar, el contenido de una lista puede convertirse en una estructura complicada, pero al mismo tiempo flexible. Esta nos permite agrupar mucha información; básicamente podemos guardar ahí lo que queramos.</p>
<p><strong>Data frames</strong></p>
<p>Un data.frame es la versión bidimensional de la matriz. Es la estructura más utilizada en la vida diaria para el análisis de datos. Podemos pensar en esta estructura como en las hojas de cálculo de Excel (aunque más útil) ya que se parece mucho en la forma en que están situados los datos. Los data frames agrupan vectores <strong>atómicos</strong> en tablas bidimensionales, de tal manera que cada vector es una columna de la tabla.</p>
<ul>
<li><code>head()</code> Vemos las 6 primeras filas por defecto.</li>
</ul>
<pre class="r"><code>datos &lt;- iris
head(datos) # cabecera</code></pre>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa</code></pre>
<pre class="r"><code>class(datos)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<p><strong>Funciones</strong></p>
<p>Las funciones también son un tipo de objeto.</p>
<pre class="r"><code>class(names)</code></pre>
<pre><code>## [1] &quot;function&quot;</code></pre>
<p>Trabajan con un <em>input</em> y devuelven un <em>output</em>. No modifican el input.</p>
<p><strong>Coerción</strong></p>
<ul>
<li>matrix() as.matrix()</li>
<li>array() as.array()</li>
<li>factor() as.factor()</li>
<li>data.frame() as.data.frame()</li>
<li>list() as.list()</li>
<li>…</li>
</ul>
<p>Supongamos que queremos convertir un vector tipo caracter en factores. Retomemos nuestro objeto <code>personas</code> creado previamente.</p>
<ul>
<li><code>is.character()</code> test/ pregunta: ¿Es character? con respuesta lógica.</li>
<li><code>is.factor()</code></li>
<li>…</li>
</ul>
<pre class="r"><code>is.character(personas)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>factor(personas)</code></pre>
<pre><code>## [1] María    Juan     Adelaida Jorge   
## Levels: Adelaida Jorge Juan María</code></pre>
<pre class="r"><code>is.character(personas)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>¿Porqué cuando preguntamos por sugunda vez si nuestro objeto <code>personas</code> es characater, nos sigue devolviendo la misma respuesta?</p>
<p>Recordemos que una de las características de R es que es dinámico. Es decir, podemos ir probando sentencias, operaciones sin guardarlas necesariamente. De ésta manera no saturamos con objetos innecesarios nuestro espacio de trabajo y preservamos nuestra estabilidad mental.</p>
<ul>
<li><code>levels()</code> Accedemos al atributo “niveles” de la variable.</li>
</ul>
<pre class="r"><code>pers.fact &lt;- as.factor(personas)
is.character(pers.fact)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>levels(pers.fact)</code></pre>
<pre><code>## [1] &quot;Adelaida&quot; &quot;Jorge&quot;    &quot;Juan&quot;     &quot;María&quot;</code></pre>
<pre class="r"><code>is.factor(pers.fact)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="acceder-a-los-elementos-de-un-vector-matriz-data.frame" class="section level2">
<h2>Acceder a los elementos de un vector / matriz / data.frame…</h2>
<div id="vector" class="section level3">
<h3>Vector</h3>
<p>La forma básica de seleccionar/extraer elementos dentro de un vector son los corchetes <code>[elemento]</code>. Existen tres maneras básicas:</p>
<ul>
<li>Por posición</li>
<li>Por valor</li>
<li>Por nombre</li>
</ul>
<p><strong>Posición</strong></p>
<p>Retomemos el objeto <code>personas</code> que creamos antes y está compuesto por cuatro elementos. Para acceder a la posición 3 (al tercer elemento) hacemos lo siguiente:</p>
<pre class="r"><code>personas[3]</code></pre>
<pre><code>## [1] &quot;Adelaida&quot;</code></pre>
<p>“Adelaida” es el elemento que ocupa la tercera posición de nuestro vector. Podemos acceder a todos menos a uno:</p>
<pre class="r"><code>personas[-3]</code></pre>
<pre><code>## [1] &quot;María&quot; &quot;Juan&quot;  &quot;Jorge&quot;</code></pre>
<p>Vemos que R nos devuelve todos los elementos menos el tercero “Adelaida”.</p>
<ul>
<li>Utilizamos el operador <code>:</code> para decir “desde <code>:</code> hasta”</li>
</ul>
<p>Ahora accedemos a los elementos que van desde el primero al tercero:</p>
<pre class="r"><code>personas[1:3]</code></pre>
<pre><code>## [1] &quot;María&quot;    &quot;Juan&quot;     &quot;Adelaida&quot;</code></pre>
<p>Siguiendo la misma lógica podríamos negar esta secuencia pero ¡ojo!, no podemos hacer lo siguiente:</p>
<pre class="r"><code>personas[-1:3]</code></pre>
<pre><code>## Error in personas[-1:3]: only 0&#39;s may be mixed with negative subscripts</code></pre>
<p>¿Podrías decir porqué?</p>
<p>La cuestión es que R interpreta que quieres acceder a los elementos que están en la posicisión desde -1 hasta la 3 ¿Cuál es la posición -1?. Pues bien, para negar esta secuencia utilizaremos los paréntesis <code>()</code>:</p>
<pre class="r"><code>personas[-(1:3)]</code></pre>
<pre><code>## [1] &quot;Jorge&quot;</code></pre>
<p>Que nos devuelve el cuarto elemento. Podemos “pasarle” a los corchetes otro vector que nos sirva de índice o incluso otras funciones.</p>
<hr />
<p><font color="green"> <em>Recuerda que los argumentos van separados por comas. Es común equivocarse al principio y no detectar dónde está el error.</em> </font></p>
<hr />
<pre class="r"><code>#Pasándole otro vector
personas[c(1, 4)]</code></pre>
<pre><code>## [1] &quot;María&quot; &quot;Jorge&quot;</code></pre>
<p>Que nos devuelve las posiciones 1 y 4.</p>
<ul>
<li><code>grepl()</code> <em>Match</em> de argumentos utilizando patrones. (Ver Cheatsheet “String manipulation”)</li>
</ul>
<p>Le pasamos una función de reconocimiento de patrones:</p>
<pre class="r"><code>personas[grepl(pattern = &quot;María&quot;, x = personas)]</code></pre>
<pre><code>## [1] &quot;María&quot;</code></pre>
<p>Que nos devuelve a el/los elementos que coinciden con el patrón “María”.</p>
<p><strong>Por valor</strong></p>
<p>Retomamos el objeto <code>numeros</code> de longitud 6 que creamos antes . Utilizamos los operadores lógicos para acceder a los elementos.</p>
<pre class="r"><code>numeros[numeros == 4] #No confundir &quot;==&quot; con &quot;=&quot;. </code></pre>
<pre><code>## [1] 4</code></pre>
<p>De la misma manera podemos utilizar cualquier otro tipo de operador lógico e incluso definir el índice fuera de la función. Retomamos nuestro objeto <code>m</code> que era una matriz 2 x 3.</p>
<pre class="r"><code>ii &lt;- m &gt; 4
m[ii]</code></pre>
<pre><code>## [1] 5 6</code></pre>
<p>Hemos creado un índice al que hemos nombrado como <code>ii</code> que responde a una sentencia lógica. El mismo lo hemos pasado a los corchetes después del objeto (que es una matriz) para indicarle a R que estamos seleccionando/ extrayendo los elementos que cumplan con la condición lógica definida en <code>ii</code>.</p>
<ul>
<li><code>%in%</code> Lo utilizamos “esto <code>en</code> este conjunto”</li>
</ul>
<p>Retomamos el objeto <code>personas</code>.</p>
<pre class="r"><code>ii &lt;- c(&quot;Pedro&quot;, &quot;Ramiro&quot;, &quot;Adelaida&quot;)
ii %in% personas</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE</code></pre>
<p>Observa que estamos haciendo una comprobación lógica por posición y R nos devuelve un lógico sobre cada elemento por el cual pregruntamos.</p>
<p>Ahora utilicemos esta idea para extraer elementos por valor.</p>
<pre class="r"><code>indice &lt;- c(1,-5)
indice %in% numeros</code></pre>
<pre><code>## [1] FALSE  TRUE</code></pre>
<p>Como puedes observar con estos secillos ejemplos, las posibilidad y la flexibilidad para el manejo de grandes bases de datos es inmensa.</p>
<p><strong>Por nombre</strong></p>
<p>Le pasamos a los corchetes un nombre y, dado que un nombre es un caracter, recuerda ponerlo entre comillas.</p>
<pre class="r"><code>personas[&quot;Juan&quot;]</code></pre>
<pre><code>## [1] NA</code></pre>
<p>¿Podrías decir porqué devuelve un error?</p>
<pre class="r"><code>names(personas) &lt;- c(&quot;María&quot;, &quot;Juan&quot;, &quot;Adelaida&quot;, &quot;Jorge&quot; )
personas[&quot;Juan&quot;]</code></pre>
<pre><code>##   Juan 
## &quot;Juan&quot;</code></pre>
</div>
<div id="matrices" class="section level3">
<h3>Matrices</h3>
<p>Hemos dicho anteriormente que una característica de un objeto tipo matriz es su bidimensionalidad y la restricción de contener elementos del mismo tipo. Fíjate en la lógica de extracción de elementos de un vector expuesta en los puntos anteriores. Utilizamos los corchetes <code>[]</code> y a ellos les “pasamos” una sentencia, índice, objeto… Le pasamos <em>una</em> por su unidimensionalidad. Ahora bien, dado que una matriz (y un data frame que veremos después) es bidimensional, a la hora de extraer / seleccionar elementos identificaremos dos posiciones dentro de los corchetes separadas por una coma. <strong>La primera posición se refiere a las filas y la segunda a las columnas.</strong> Veámoslo con un ejemplo y recuperemos nuestro objeto <code>m</code> definido anteriormente.</p>
<p>Supongamos que queremos extraer o referirnos a la primera fila:</p>
<pre class="r"><code>m[1,]</code></pre>
<pre><code>## [1] 1 2 3</code></pre>
<p>Observa que efectivamente R nos devuelve la primera fila de la matriz. Ahora extraigamos la segunda columna:</p>
<pre class="r"><code>m[,2]</code></pre>
<pre><code>## [1] 2 5</code></pre>
<p>Observa que la primera posición, que se refiere a las filas, la hemos dejado en blanco. Ahora extraigamos el elemento que se encuentra en la segunda fila y la tercera columna:</p>
<pre class="r"><code>m[2,3]</code></pre>
<pre><code>## [1] 6</code></pre>
<p>La misma lógica que seguimos para extraer elementos de un vector es valida para los objetos bidimensionales.</p>
</div>
<div id="data-frame" class="section level3">
<h3>Data frame</h3>
<ul>
<li><code>$</code> Operador con el que extraemos variables de un data.frame</li>
</ul>
<p>El objeto tipo <code>data.frame</code> es uno de los más utilizados. Tanto es así, que incluso cuenta con un operador propio que nos permitirá seleccionar variables. Recuperamos nuestro objeto <code>datos</code>.</p>
<ul>
<li><code>tail()</code> Nos devuelve las 6 últimas filas por defecto.</li>
</ul>
<pre class="r"><code>tail(datos$Sepal.Length, n = 4)</code></pre>
<pre><code>## [1] 6.3 6.5 6.2 5.9</code></pre>
<p>Observa la anterior sentencia. Hemos “aninado” operaciones de dentro hacía afuera. Primero seleccionamos la variable <code>Sepal.Length</code> y después a esa operación le hemos aplicado la función <code>tail()</code> pasándole a <code>tail()</code> el argumento <code>n = 4</code>, es decir, que nos devuelva las últimas cuatro filas del data frame <code>datos</code>. Podríamos seguir incluso anidando más sentencias:</p>
<ul>
<li><code>sd()</code> Nos da la cuasi-desviación típica.</li>
</ul>
<pre class="r"><code>sd(tail(datos$Sepal.Length, n = 4))</code></pre>
<pre><code>## [1] 0.25</code></pre>
<p>¿Podrías decir que hemos hecho en la anterior operación?</p>
<p>Efectivamente. Hemos calculado la cuasi-desviación típica de los cuatro últimos valores de la variable <code>Sepal.Length</code> de nuestro data frame <code>datos</code>.</p>
<hr />
<p><font color="green"> <em>Tip: Observa que cuando tecleas el perador <code>$</code> después de tu data frame en RStudio te aparece un menú desplegable con todas tus variables. Este autocompletado te ahorra mucho tiempo escribiendo e incluso a veces sirve de exploración rápida. Utilízalo.</em> </font></p>
<hr />
<p>De la misma manera que extraímos filas, columnas y valores concretos con los corchetes en las matrices, podemos utilizarlos en los dataframes. Supongamos que queremos extraer la cuarta fila del objeto <code>datos</code>:</p>
<pre class="r"><code>datos[4,]</code></pre>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 4          4.6         3.1          1.5         0.2  setosa</code></pre>
<p>O bien la séptima fila de la variable <code>Species</code>:</p>
<pre class="r"><code>datos[7,&quot;Species&quot;]</code></pre>
<pre><code>## [1] setosa
## Levels: setosa versicolor virginica</code></pre>
<p>Además del valor “setosa”, R nos devuelve los niveles del factor que hemos seleccionado. Supongamos que queremos hacer una comprobación lógica y nos preguntamos si el valor de la séptima fila de la variable <code>Species</code> es “versicolor”.</p>
<pre class="r"><code>datos[7,&quot;Species&quot;] == &quot;versicolor&quot;</code></pre>
<pre><code>## [1] FALSE</code></pre>
</div>
</div>
<div id="atributos" class="section level2">
<h2>Atributos</h2>
<p>Un atributo es información que podemos “pegar” a un vector atómico o a cualquier objeto. Éstos no afectan a los valores y tampoco los veremos cuando mandamos llamar a un objeto. Podemos pensar en ellos como en una especie de metadatos. Generalmente R ignorará esta información, sin embargo, muchas funciones bucean en los atributos para poder operar de manera conveniente. Si un objeto no tiene atributos veremos la salida <code>NULL</code>.</p>
<pre class="r"><code>attributes(1)</code></pre>
<pre><code>## NULL</code></pre>
<p>Atributos comunes son:</p>
<ul>
<li><code>names()</code> Nombres.</li>
<li><code>dim()</code> Dimensión (útil para matrices y data.frames).</li>
</ul>
<p>Probemos con nuestro objeto <code>datos</code> creado anteriormente.</p>
<pre class="r"><code>names(datos); dim(datos)</code></pre>
<pre><code>## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot;  &quot;Petal.Length&quot; &quot;Petal.Width&quot;  &quot;Species&quot;</code></pre>
<pre><code>## [1] 150   5</code></pre>
</div>
<div id="funciones-propias" class="section level2">
<h2>Funciones propias</h2>
<p><font color="green"> <em>Tip: Guarda tus funciones en scripts aparte, coméntalas correctamente y reutilízalas cuando las necesites cargándolas a la sesión con <code>load("mifuncion.R")</code></em> </font></p>
<p>La estructura general es:</p>
<pre class="r"><code>mifuncion &lt;- function(arumento1, argumento2, ...) {
        expresiones
        return(objeto)
}</code></pre>
<p>Es importante por motivos de estilo y para leer el código con mayor facilidad mantener esta estructura. Toda función en R cuenta con tres partes elementales:</p>
<ul>
<li>Nombre de la función.</li>
<li>Cuerpo (el código entre corchetes).</li>
<li>Argumentos.</li>
</ul>
<p>Observemos que cada línea del código entre corchetes (el cuerpo) suele ser una sentencia u operación. Aunque R ignora los espacios, separarlo en líneas hace más fácil la lectura y R ejecuta la expresión entera entre corchetes.</p>
<p><strong>Cuerpo</strong></p>
<p>Veamos un ejemplo.</p>
<ul>
<li><code>sample()</code> Toma una muestra de n elementos de x con o sin remplazamiento.</li>
</ul>
<pre class="r"><code>#función anónima
tirar.dado &lt;- function() {
        dado &lt;- 1:6
        dado.s &lt;- sample(dado, 2)
        sum(dado.s)
} </code></pre>
<p>Vemos que nos devuelve como resultado la última operación del cuerpo de la función. Si mandamos llamar nuestra función sin los paréntesis nos devuelve el cuerpo de la función:</p>
<pre class="r"><code>tirar.dado</code></pre>
<pre><code>## function() {
##         dado &lt;- 1:6
##         dado.s &lt;- sample(dado, 2)
##         sum(dado.s)
## }</code></pre>
<pre class="r"><code>body(tirar.dado) #equivalente</code></pre>
<pre><code>## {
##     dado &lt;- 1:6
##     dado.s &lt;- sample(dado, 2)
##     sum(dado.s)
## }</code></pre>
<p><strong>Argumentos</strong></p>
<hr />
<p><font color="green"> <em>Tip: Podemos consultar los argumentos de una función propia o de una librería con <code>?lafuncion()</code> No intentes aprenderte todos los argumentos de una función. </em> </font></p>
<hr />
<p>La anterior función es “anónima”; opera sin necesidad de pasarle ningún argumento. Lo interesante es que podemos pasarle cualquier vector, operación, objeto, ¡otra función!… a nuestra función y pedirle que opere con él.</p>
<ul>
<li><code>length()</code> Nos devuelve la longitud del vector.</li>
<li><code>sum()</code> Suma los elementos del vector numérico.</li>
<li><code>return()</code> Nos devuelve el valor de la expresión evaluada.</li>
</ul>
<pre class="r"><code>mimedia &lt;- function(x) {
        media &lt;- sum(x) / length(x) 
        return(media)
}
mimedia()</code></pre>
<pre><code>## Error in mimedia(): argument &quot;x&quot; is missing, with no default</code></pre>
<p>Nos devuelve un error porque la función <code>mimedia</code> necesita al objeto <code>x</code>, que no hemos definido, para realizar su función. Al objeto <code>x</code> podemos definirlo (i) dentro del cuerpo de la función, (ii) asignándole valores por defecto al argumento o, (iii) fuera de la función.</p>
<p><em>(i)</em></p>
<pre class="r"><code>mimedia &lt;- function(x) {
        x &lt;- 1:6
        media &lt;- sum(x) / length(x) 
        return(media)
}
mimedia()</code></pre>
<pre><code>## [1] 3.5</code></pre>
<p><em>(ii)</em></p>
<pre class="r"><code>mimedia &lt;- function(x = 1:6) {
        media &lt;- sum(x) / length(x) 
        return(media)
}
mimedia()</code></pre>
<pre><code>## [1] 3.5</code></pre>
<p><em>(iii)</em></p>
<pre class="r"><code>a &lt;- 1:6
mimedia &lt;- function(x) {
        media &lt;- sum(x) / length(x) 
        return(media)
}
mimedia(x = a) </code></pre>
<pre><code>## [1] 3.5</code></pre>
<hr />
<p><font color="green"> Tip: Para el cuerpo de las funciones creadas por nosotros es mejor acceder a los elementos de la manera básica que con el universo <code>tidyverse</code> u otras librerías. </font></p>
<hr />
</div>
<div id="lectura-y-escritura-de-datos" class="section level2">
<h2>Lectura y escritura de datos</h2>
<p><strong>Directorio de trabajo</strong></p>
<p>Cada vez que abrimos R la sesión se vincula a un directorio por defecto <em>(working directory)</em>. Es ahí donde R busca los datos cuando intentamos cargarlos y es ahí donde los guarda. Para saber que directorio se está utilizando:</p>
<pre class="r"><code>getwd()</code></pre>
<pre><code>## [1] &quot;C:/Users/javro/Documents/probando2/docs&quot;</code></pre>
<p>Si queremos cambiarlo tendremos que especificar la ruta completa con la función <code>setwd()</code>. Ésta podemos copiarla y pegarla de las ventanas de navegación e, importante, tenemos que sustituir el <em>backslash</em> <code>\</code> por <code>/</code> y entrecomillar el texto.</p>
<pre class="r"><code>setwd(&quot;una_carpeta/miproyecto&quot;)</code></pre>
<p>Lo más recomendable, a efectos de compartir código es abrir un nuevo “proyecto” en el entorno de RStudio. De esta manera no tendremos que cambiar en cada sesión nuestro directorio de trabajo y, sobre todo, no tendremos que enviar código basura a nuestros colaboradores.</p>
<p><strong>Textos planos</strong></p>
<p>Es una de las maneras más comunes de almacenar datos (el .csv, .txt … son textos planos) porque son muy simples y pueden ser leídos por muchos programas incluso por editores de texto básicos como un bloc de notas. Si te das cuenta, los datos públicos abiertos suelen venir en este formato. La función más común para leer texto plano es <code>read.table</code> que admite los siguientes argumentos entre otros (recuerda que puedes ver los argumentos que acepta cualquier función consultando la ayuda de r <code>?unafuncion()</code>):</p>
<ul>
<li>sep</li>
<li>header</li>
<li>na.strings</li>
</ul>
<p><em>Cargamos el archivo <code>calidadaire.txt</code> al entorno de trabajo</em></p>
<pre class="r"><code>datos &lt;- read.table(&quot;DATA/calidadaire.txt&quot;, header = T)</code></pre>
<p>A su vez podemos guardar el objeto, supongamos que en formato .csv utilizando la función <code>write.csv</code>. Observa que es muy intuitivo y sigue la misma lógica para otras extensiones.</p>
<p><strong>Otros tipos de archivos</strong></p>
<p>Si bien es lo más común trabajar con texto plano, hemos de saber que en R podemos leer prácticamente cualquier tipo de archivos, desde html’s, acceder a API’s, sql, mysql, wikipedia, .px, .tiff, .sav, .dbf, .xlxs … Aunque para ello tendremos que instalar paquetes desde el repositorio CRAN o desde cualquier otro. (Ver cargar paquetes) Una de las librerías más utilizadas (utilizamos indistintamente librerías y paquetes en este contexto) para cargar datos procedentes de SW específico es <code>foreign</code> que instalaremos en nuestro equipo y cargaremos como hemos aprendido antes.</p>
<pre class="r"><code>library(foreign)</code></pre>
<ul>
<li><code>ls()</code> Nos devuelve los objetos de un entorno específico.</li>
</ul>
<hr />
<p><font color="green"> <em>Tip: Con la siguiente sentencia podemos ver el listado de todas las funciones de una librería: ls(“package:foreign”)</em> </font></p>
<hr />
<pre class="r"><code>ls(&quot;package:foreign&quot;)</code></pre>
<pre><code>##  [1] &quot;data.restore&quot;  &quot;lookup.xport&quot;  &quot;read.arff&quot;     &quot;read.dbf&quot;      &quot;read.dta&quot;      &quot;read.epiinfo&quot;  &quot;read.mtp&quot;      &quot;read.octave&quot;  
##  [9] &quot;read.S&quot;        &quot;read.spss&quot;     &quot;read.ssd&quot;      &quot;read.systat&quot;   &quot;read.xport&quot;    &quot;write.arff&quot;    &quot;write.dbf&quot;     &quot;write.dta&quot;    
## [17] &quot;write.foreign&quot;</code></pre>
<p>Supongamos que queremos leer un archivo .sav</p>
<pre class="r"><code>datos &lt;- read.spss(&quot;DATA/control.sav&quot;, to.data.frame = T) #es recomendable convertir los archivos .sav a objetos tipo data.frame utilizando el argumento to.data.frame = T</code></pre>
<p>Para una consulta rápida podemos consultar la “chuleta” (<em>Cheatsheet</em>) “data_import”.</p>
</div>
<div id="exploración-inicial-de-un-data.frame" class="section level2">
<h2>Exploración inicial de un data.frame</h2>
<p>Una vez hemos abierto un proyecto nuevo o abierto uno ya existente, hemos cargado nuestros datos en la sesión y hemos llamado a nuestras librerías si es el caso, solemos realizar una serie de operaciones para darnos una idea de los datos con los que estamos trabajando.</p>
<p>Asignemos al objeto <code>datos</code> el data set <code>iris</code></p>
<pre class="r"><code>datos &lt;- iris</code></pre>
<ul>
<li><code>View(datos)</code> Invocamos una hoja donde podemos explorar los datos. No es recomendable si tenemos una base muy pesada.</li>
</ul>
<pre class="r"><code>View(datos)</code></pre>
<p>Vemos los nombres de las variables:</p>
<pre class="r"><code>names(datos)</code></pre>
<pre><code>## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot;  &quot;Petal.Length&quot; &quot;Petal.Width&quot;  &quot;Species&quot;</code></pre>
<p><code>names()</code> Nos devuelve un vector caracter con el atributo “nombre” de cada variable en <code>datos</code>.</p>
<p>Vemos la cabecera y la cola de los datos:</p>
<pre class="r"><code>head(datos)</code></pre>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa</code></pre>
<pre class="r"><code>tail(datos)</code></pre>
<pre><code>##     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
## 145          6.7         3.3          5.7         2.5 virginica
## 146          6.7         3.0          5.2         2.3 virginica
## 147          6.3         2.5          5.0         1.9 virginica
## 148          6.5         3.0          5.2         2.0 virginica
## 149          6.2         3.4          5.4         2.3 virginica
## 150          5.9         3.0          5.1         1.8 virginica</code></pre>
<ul>
<li><code>str()</code> Nos informa sobre la estructura interna de nuestro data frame.</li>
</ul>
<pre class="r"><code>str(datos)</code></pre>
<pre><code>## &#39;data.frame&#39;:    150 obs. of  5 variables:
##  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
##  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
##  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
##  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
##  $ Species     : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...</code></pre>
<p>Vemos que nos da la información del objeto <code>datos</code>. Nos dice que es un “data.frame” de dimensiones 150 x 5 (las dimension podemos obtenerla con <code>dim()</code>) y de cada variable nos indica que tipo de objeto es. Si nuestra variable es factor nos indica el número de niveles y además nos muestra los primeros valores de cada variable.</p>
<ul>
<li><code>missmap()</code> Vistazo gráfico de nuestros valores perdidos. Es necesario cargar la librería <code>library(Amelia)</code>. No recomendable para bases muy grandes.</li>
</ul>
<pre class="r"><code>library(Amelia)
missmap(datos)</code></pre>
<p><img src="intro_basica_files/figure-html/unnamed-chunk-79-1.png" width="672" /></p>
<ul>
<li><code>summary()</code> Es una función genérica. Ver detalles con <code>?summary()</code></li>
</ul>
<p>En nuestro ejemplo <code>summary()</code> nos devuelve los estadísticos principales:</p>
<pre class="r"><code>summary(datos)</code></pre>
<pre><code>##   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width          Species  
##  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100   setosa    :50  
##  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300   versicolor:50  
##  Median :5.800   Median :3.000   Median :4.350   Median :1.300   virginica :50  
##  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199                  
##  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800                  
##  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500</code></pre>
<p>R nos devuelve de cada variable continua el mínimo, el máximo, el primer y tercer cuartil además de la media y la mediana. De la variable factor hace un conteo de las observaciones por nivel. En nuestro ejemplo no tenemos valores perdidos, si los hubiere, también vendrían especificados para cada variable.</p>
<ul>
<li><code>var()</code> Nos da la cuasivarianza de un vector numérico.</li>
</ul>
<p>La función <code>summary()</code> no nos da la cuasivarianza por defecto. Para calcularla utilizamos:</p>
<pre class="r"><code>var(datos$Sepal.Length)</code></pre>
<pre><code>## [1] 0.6856935</code></pre>
<pre class="r"><code>round(var(datos$Sepal.Length), 3)</code></pre>
<pre><code>## [1] 0.686</code></pre>
<p>Si queremos saber la cuasivarianza de todas las variables numéricas de nuestro data frame ¿Iremos calculando una por una? Lo mejor es pasarle un ciclo. Hemos especificado anteriormente el “ciclo for”, sin embargo, hemos de saber que en R los <em>loops</em> “naturales” son los pertenecientes a la familia <code>apply</code> que iremos introduciendo durante el curso.</p>
<ul>
<li><code>lapply(x = vector, función)</code> Aplica a cada elemento una función y nos devuelve un objeto tipo <code>list()</code>.</li>
</ul>
<p>A cada una de las variables numéricas les pasamos la función <code>var()</code>. Observa que no es necesario en este caso poner los paréntesis despues de <code>var</code>.</p>
<pre class="r"><code>lapply(datos[,1:4], var)</code></pre>
<pre><code>## $Sepal.Length
## [1] 0.6856935
## 
## $Sepal.Width
## [1] 0.1899794
## 
## $Petal.Length
## [1] 3.116278
## 
## $Petal.Width
## [1] 0.5810063</code></pre>
<p>Si no nos gusta esta presentación podemos convertir la lista que nos ha devuelto R en un data.frame coercionando el objeto y además redondeando a 3 decimales. (Ver coercionar).</p>
<pre class="r"><code>round(as.data.frame(lapply(datos[,1:4], var)), 3)</code></pre>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width
## 1        0.686        0.19        3.116       0.581</code></pre>
</div>
<div id="operaciones-con-variables" class="section level2">
<h2>Operaciones con variables</h2>
<p>En este epígrafe veremos dos enfoques muy comunes en el tratamiento de datos en R. El primero es el enfoque <code>tidyverse</code> y el segundo con R base. Empezaremos mostrando el primero.</p>
<p>Cargaremos la librería <code>dplyr</code>.</p>
<pre class="r"><code>library(dplyr)</code></pre>
<p>Podemos ver que el número de funciones que contiene esta librería es muy grande, y es que es una de las más utilizandas para el manejo de datos.l</p>
<pre class="r"><code>length(ls(&quot;package:dplyr&quot;))</code></pre>
<pre><code>## [1] 290</code></pre>
<p>Por el momento vamos a quedarnos con cinco funciones básicas que nos darán mucho juego en el manejo de datos diario:</p>
<ul>
<li><code>select()</code> Selección de variables.</li>
<li><code>filter()</code> Selecciona casos (filas) en las que se cumplen condiciones.</li>
<li><code>mutate()</code> Crea nuevas variables.</li>
<li><code>group_by()</code> Agrupa valores.</li>
<li><code>arrange()</code> Ordena valores.</li>
<li><code>summarise()</code> Realiza resumenes. Trabaja con datos agrupados por <code>group_by()</code>.</li>
<li><code>%&gt;%</code> Pipe. Concatena sentencias.</li>
</ul>
<p><font color="red"> <em>Desde la version de R 4.1 el operador pipe se encuentra disponible en base y no hace falta cargar maggrittr o tidyverse</em> </font></p>
<ul>
<li><code>|&gt;</code> Nuevo Pipe</li>
</ul>
<p><strong>select()</strong></p>
<p>Retomemos nuestro objeto <code>datos</code> creado anteriormente. Vamos a utilizar <code>select()</code> para seleccionar (como su nombre indica) columnas. Observa que vamos a ir encadenando sentencias con el perador <code>%&gt;%</code>, contrario a ir “anidando” ordenes como es en R base.</p>
<p>Supongamos que queremos seleccionar la variable “Sepal.Width” y ver sus primeras 6 filas:</p>
<pre class="r"><code>datos %&gt;% select(Sepal.Width) %&gt;% 
        head()</code></pre>
<pre><code>##   Sepal.Width
## 1         3.5
## 2         3.0
## 3         3.2
## 4         3.1
## 5         3.6
## 6         3.9</code></pre>
<p>Ahora seleccionamos todas menos “Sepal.Width” y vemos la cabecera:</p>
<pre class="r"><code>datos %&gt;% select(-Sepal.Width) %&gt;% 
        head()</code></pre>
<pre><code>##   Sepal.Length Petal.Length Petal.Width Species
## 1          5.1          1.4         0.2  setosa
## 2          4.9          1.4         0.2  setosa
## 3          4.7          1.3         0.2  setosa
## 4          4.6          1.5         0.2  setosa
## 5          5.0          1.4         0.2  setosa
## 6          5.4          1.7         0.4  setosa</code></pre>
<p>Observa de que a pesar de que estamos llamando a la variable por su nombre en la sintáxis de <code>dplyr()</code> no estamos obligados a ponerlo entre comillas.</p>
<p><font color="green"> <em>Tip: Cuando encadenes sentencias con <code>%&gt;%</code> reserva una línea para cada orden. De esta manera será fácil seguir tu razonamiento.</em> </font></p>
<p>De la misma manera que extraíamos / seleccionabamos en Rbas (por posición, valor y nombre) podemos hacerlo en <code>dplyr</code>. La cabecera de las tres primeras columnas y de la quinta:</p>
<pre class="r"><code>datos %&gt;% select(c(1:3, 5)) %&gt;% head()</code></pre>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Species
## 1          5.1         3.5          1.4  setosa
## 2          4.9         3.0          1.4  setosa
## 3          4.7         3.2          1.3  setosa
## 4          4.6         3.1          1.5  setosa
## 5          5.0         3.6          1.4  setosa
## 6          5.4         3.9          1.7  setosa</code></pre>
<p><strong>filter()</strong></p>
<p>Utilizamos <code>filter()</code> para seleccionar casos. Vayamos concatenando sentencias. Supongamos que queremos extraer las observaciones de “Sepal.Width” pero sólo de aquellas flores que son “versicolor”:</p>
<pre class="r"><code>datos %&gt;% select(Sepal.Width, Species) %&gt;% 
        filter(Species == &quot;versicolor&quot;) %&gt;% head() #utilizamos head() al final por cuestiones de espacio en el documento. </code></pre>
<pre><code>##   Sepal.Width    Species
## 1         3.2 versicolor
## 2         3.2 versicolor
## 3         3.1 versicolor
## 4         2.3 versicolor
## 5         2.8 versicolor
## 6         2.8 versicolor</code></pre>
<p>Dado que podemos seleccionar casos que cumplan con ciertos criterios, entonces también podemos utilizar operadores lógicos. De la operación anterior, además de seleccionar la especie “versicolor” queremos también la “setosa” y con una anchura de sépalo mayor que 3.7mm, entonces:</p>
<pre class="r"><code>datos %&gt;% select(Sepal.Width, Species) %&gt;% 
        filter(Species == &quot;versicolor&quot; | Species == &quot;setosa&quot;,
               Sepal.Width &gt; 3.7) </code></pre>
<pre><code>##    Sepal.Width Species
## 1          3.9  setosa
## 2          4.0  setosa
## 3          4.4  setosa
## 4          3.9  setosa
## 5          3.8  setosa
## 6          3.8  setosa
## 7          4.1  setosa
## 8          4.2  setosa
## 9          3.8  setosa
## 10         3.8  setosa</code></pre>
<p><strong>mutate()</strong></p>
<p>Utilizamos mutate para crear nuevas variables que pueden ser el producto de una operación o simplemente cualquier valor.</p>
<pre class="r"><code>datos %&gt;% select(Sepal.Width) %&gt;% 
        mutate(unos = 1) %&gt;% 
        head()</code></pre>
<pre><code>##   Sepal.Width unos
## 1         3.5    1
## 2         3.0    1
## 3         3.2    1
## 4         3.1    1
## 5         3.6    1
## 6         3.9    1</code></pre>
<p>Simplemente hemos puesto un uno en cada fila y hemos nombrado a esa nueva variable como “uno”. Pero podríamos realizar operaciones un poco más complejas. Supongamos que estamos interesador en crear una nueva variable que nos diga para cada observación de <code>Sepal.Width</code> si está por encima de su media o no. Pondremos un “TRUE” si lo está y un “FALSE” si no. ¿Cómo lo harías?</p>
<p>Utilizaremos <code>ifelse()</code> (Ver estructura <code>ifelse</code>):</p>
<pre class="r"><code>sw &lt;- datos$Sepal.Width
datos %&gt;% select(Sepal.Width) %&gt;% 
        mutate(mayor = ifelse(test = sw &gt; mean(sw), 
                              yes = TRUE, 
                              no = FALSE)) %&gt;%
        head()</code></pre>
<pre><code>##   Sepal.Width mayor
## 1         3.5  TRUE
## 2         3.0 FALSE
## 3         3.2  TRUE
## 4         3.1  TRUE
## 5         3.6  TRUE
## 6         3.9  TRUE</code></pre>
<p>Comprueba que la media de <code>Sepal.Width</code> es 3.057333.</p>
<p><strong>group_by()</strong></p>
<ul>
<li><code>summarise_all()</code> Aplica una función a todas las variables no agrupadas.</li>
</ul>
<pre class="r"><code>datos %&gt;% group_by(Species) %&gt;% summarise_all(funs(mean))</code></pre>
<pre><code>## # A tibble: 3 x 5
##   Species    Sepal.Length Sepal.Width Petal.Length Petal.Width
##   &lt;fct&gt;             &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
## 1 setosa             5.01        3.43         1.46       0.246
## 2 versicolor         5.94        2.77         4.26       1.33 
## 3 virginica          6.59        2.97         5.55       2.03</code></pre>
<p><strong>arrange()</strong></p>
<p><strong>summarise()</strong></p>
<div id="recodificación" class="section level4">
<h4>Recodificación</h4>
<p>Para recodificar valores necesitamos un vector lógico que determine los valores que vamos a recodificar según el criterio, que queramos; después simplemente asignamos el nuevo valor.</p>
<pre class="r"><code>datos$variable[vector.logico] &lt;- nuevo.valor
# ánalogos
datos[ vector.logico,&quot;variable&quot;] &lt;- nuevo.valor</code></pre>
<p>Vamos a recodificar los valores superiores al percentil 75 de la variable longitud del Petalo de nuestro datos</p>
<pre class="r"><code>quantile(datos$Petal.Length)</code></pre>
<pre><code>##   0%  25%  50%  75% 100% 
## 1.00 1.60 4.35 5.10 6.90</code></pre>
<pre class="r"><code>datos$Petal.Length[datos$Petal.Length &gt; 5.10 ] &lt;- 5.1</code></pre>
<p><strong>Recodificar factores</strong></p>
<p>Si queremos cambiar los niveles de un factor</p>
<pre class="r"><code>datos$Species &lt;- factor(datos$Species,labels = c(&quot;se&quot;,&quot;ve&quot;,&quot;vi&quot;))</code></pre>
<p>Tmabién es común y útil coercionar a character con <code>as.character()</code> y luego recodificar.</p>
<pre class="r"><code>sp &lt;- as.character(datos$Species)


sp[sp == &quot;setosa&quot;] &lt;- &quot;se&quot;
sp[sp == &quot;versicolor&quot;] &lt;- &quot;ve&quot;
sp[sp == &quot;virginica&quot;] &lt;- &quot;vi&quot;

datos$Species &lt;- factor(sp)</code></pre>
<p>Dado un valor númerico podemos convertirlo en factor con la misma función empleando esta vez los dos argumentos levels y labels</p>
<ul>
<li><strong>Función cut</strong>:</li>
</ul>
<p>A veces es conveniente transformar una variable continua en una categórica o factor. Para ello empleamos la función <code>cut()</code>. Esta sirve para dividir en grupos en una variable continua. Existen dos formas de realizar esta operación, la primera es pasándole el número de cortes que queremos hacer. Esto dividirá el rango entre el número indicado.</p>
<pre class="r"><code>datos$cPet4 &lt;- cut(datos$Petal.Length, breaks = 4)

class(datos$cPet4)</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<pre class="r"><code>nlevels(datos$cPet4)</code></pre>
<pre><code>## [1] 4</code></pre>
<pre class="r"><code>head(datos[,c(&quot;Petal.Length&quot;,&quot;cPet4&quot;)]) </code></pre>
<pre><code>##   Petal.Length        cPet4
## 1          1.4 (0.996,2.02]
## 2          1.4 (0.996,2.02]
## 3          1.3 (0.996,2.02]
## 4          1.5 (0.996,2.02]
## 5          1.4 (0.996,2.02]
## 6          1.7 (0.996,2.02]</code></pre>
<p>Otra forma de hacerlo es determinar los cortes de forma manual con un vector para los cortes</p>
<pre class="r"><code>limites &lt;- c(0,1.60,5.10,7)

datos$cPet4 &lt;- cut(datos$Petal.Length, breaks = limites)

head(datos[3:6,c(&quot;Petal.Length&quot;,&quot;cPet4&quot;)]) </code></pre>
<pre><code>##   Petal.Length     cPet4
## 3          1.3   (0,1.6]
## 4          1.5   (0,1.6]
## 5          1.4   (0,1.6]
## 6          1.7 (1.6,5.1]</code></pre>
<p>Como indica el corchete el criterio de inclusión es por la izquierda. Podemos alterarlo con el argumento <code>right</code>, además podemos determinar las etiquetas con el argumento <code>label</code> por último podemos indicar si queremos que el resultado sea un factor o un factor ordenado.</p>
<pre class="r"><code>datos$cPet4 &lt;- cut(datos$Petal.Length, breaks = limites, right = F, labels = c(&quot;Uno&quot;,&quot;Dos&quot;,&quot;Tres&quot;),ordered_result = T)
levels(datos$cPet4)</code></pre>
<pre><code>## [1] &quot;Uno&quot;  &quot;Dos&quot;  &quot;Tres&quot;</code></pre>
</div>
<div id="valores-perdidos" class="section level4">
<h4>Valores perdidos</h4>
<p>Los valores perdidos en R son representados en <em>R</em> con un <code>NA</code></p>
<pre class="r"><code>x &lt;- c(1,3,5,3,2,NA,13,13,4,2,1,NA)
x</code></pre>
<pre><code>##  [1]  1  3  5  3  2 NA 13 13  4  2  1 NA</code></pre>
<p>En este caso el vector es muy pequeño y podemos ver los valores perdidos pero en caso de no ser asi podemos ver cuales son estos con una rpegunta lógica:</p>
<pre class="r"><code>is.na(x)</code></pre>
<pre><code>##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE</code></pre>
<p>Podemos sumar este vector para ver el numero de casos perdidos</p>
<pre class="r"><code>sum(is.na(x))</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Ahora veamoslo en acción con nuestros datos, hemos añadido unos cuantos valores perdidos.</p>
<pre class="r"><code>sum(is.na(datos.na$Sepal.Width))</code></pre>
<pre><code>## [1] 23</code></pre>
<p>Vemos que hay 23 valores perdidos.</p>
<p>Podemos usar la función de familias apply para ver cuantos hay en cada variable. En esta ocasión tenemos</p>
<pre class="r"><code>sapply(datos.na, function(x) sum(is.na(x)))</code></pre>
<pre><code>## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
##            0           23           90            5           11</code></pre>
<p>Como vemos esta vez hemos llamado a function(x) antes , lo que hemos hecho es pasar una función anonima. Estas funciones son empleadas had hoc para tareas concretas. Básicamente son funciones definidas en la propia linea. La linea de código anterior sería equivalente a:</p>
<pre class="r"><code>per &lt;- function(x){
  sum(is.na(x))
}

sapply(datos.na,per)</code></pre>
<pre><code>## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
##            0           23           90            5           11</code></pre>
<p>Las funciones anónimas son muy útiles en combinación con la <code>familia apply</code> ya que podemos emplearla también para añadir argumentos a la función aplicada como veremos más adelante.</p>
<p>La función summary vista con anterioridad también proporciona el número de perdidos</p>
<pre class="r"><code>summary(datos.na)</code></pre>
<pre><code>##   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width          Species  
##  Min.   :4.300   Min.   :2.000   Min.   :1.200   Min.   :0.100   setosa    :39  
##  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.675   1st Qu.:0.300   versicolor:50  
##  Median :5.800   Median :3.000   Median :4.400   Median :1.300   virginica :50  
##  Mean   :5.843   Mean   :3.072   Mean   :3.985   Mean   :1.213   NA&#39;s      :11  
##  3rd Qu.:6.400   3rd Qu.:3.400   3rd Qu.:5.275   3rd Qu.:1.800                  
##  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500                  
##                  NA&#39;s   :23      NA&#39;s   :90      NA&#39;s   :5</code></pre>
<p>Otra forma de <code>missmap()</code> Vistazo gráfico de nuestros valores perdidos. Es necesario cargar la librería <code>library(Amelia)</code>. No recomendable para bases muy grandes.</p>
<pre class="r"><code>library(Amelia)
missmap(datos.na)</code></pre>
<div class="figure">
<img src="intro_basica_files/figure-html/unnamed-chunk-109-1.png" alt="Mapa de perdidos" width="672" />
<p class="caption">
Mapa de perdidos
</p>
</div>
<p>Ahora que tenemos identificados los valores perdidos podemos hacer algo al respecto. Imaginemos que queremos descartar Petal.Length ( la tercera columna, la función missmap los ordena de mayor número de perdidos a menor)</p>
<pre class="r"><code>datos.na &lt;- datos.na[,-3]
datos.na &lt;- datos.na[,c(1:4)]
datos.na &lt;- datos.na[,c(&quot;Species&quot;,&quot;Petal.Width&quot;,&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)]
# equivalentes</code></pre>
<p>Otra forma de tratar con valores perdidos, es ignorar las observaciones que contengan alguno para ello podemos emplear <code>completecases</code>. Esta función devuelve un vector logico con las filas que contienen todos los casos.</p>
<pre class="r"><code>complete.cases(datos.na)</code></pre>
<pre><code>##   [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE
##  [22]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE
##  [43] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
##  [64]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE
##  [85]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE
## [106] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [127]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE
## [148] FALSE  TRUE FALSE</code></pre>
<pre class="r"><code># ahora se la pasamos a las filas

datos.na2 &lt;- datos.na[complete.cases(datos.na),]
missmap(datos.na2)</code></pre>
<p><img src="intro_basica_files/figure-html/unnamed-chunk-112-1.png" width="672" /></p>
<p>Como vemos la matriz esta “limpia” lamentablemente en el proceso perdemos información. Otra forma de lidiar con los valores perdidos es ignorarlos.</p>
<p>Imaginemos que queremos sacar la media de “Petal.Width”</p>
<pre class="r"><code>mean(datos.na$Petal.Length)</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Al haber valores perdidos nos retorna <code>NA</code> pero saber la media de la variable deberiamos hacer lo siguiente.</p>
<pre class="r"><code>mean(datos.na$Petal.Length[!is.na(datos.na$Petal.Length)])</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Afortunamende muchas funciónes incroporan un argumento para lidiar con los valores perdidos. En este caso el argumento <code>na.rm</code>(NA remove) nos permite omitir estos casos para el calculo</p>
<pre class="r"><code>mean(datos.na$Petal.Length, na.rm = T)</code></pre>
<pre><code>## [1] NA</code></pre>
</div>
</div>
<div id="frecuencias" class="section level2">
<h2>Frecuencias</h2>
<p>Para obtener las frecuencias de una variable en R empleamos al función <code>table()</code>. Esta nos devuelve un vector de las frecuencias (con los nombres).</p>
<pre class="r"><code>table(datos$Species)</code></pre>
<pre><code>## 
## se ve vi 
## 50 50 50</code></pre>
<p>Podemos obtener una tabla de contingencia añadiendo el otro vector a la función.</p>
<pre class="r"><code>table(datos$Species,datos$cPet4)</code></pre>
<pre><code>##     
##      Uno Dos Tres
##   se  37  13    0
##   ve   0  49    1
##   vi   0   9   41</code></pre>
<p>El argumento useNA nos permite excluir los valores perdidos en caso de haberlos.</p>
</div>
<div id="distribuciones" class="section level2">
<h2>Distribuciones</h2>
<p>Presentamos distribuciones notables desde el punto de vista del código para generarlas. Asumimos que los alumnos ya tienen alguna experiencia previa en probabilidad y estadística.</p>
<p><strong>Binomial</strong></p>
<p>Sea <span class="math inline">\(X \in B(n,p)\)</span> una v.a. con función de probabilidad: <span class="math display">\[P(X = x) = \binom{n}{x}p^xq^{n-x} \;\;\;\; \text{si}\;\;\;x=0,1,2,...,n\]</span> Con, <span class="math display">\[E(X) = np, \;\;\;\;\; Var(X) = npq\]</span></p>
<p>En R tenemos cuatro sentencias:</p>
<ul>
<li><code>pbinom()</code> Probabilidad acumulada.</li>
<li><code>dbinom()</code> Densidad.</li>
<li><code>qbinom()</code> Cuantil.</li>
<li><code>rbinom()</code> Números pseudo-aleatorios que seguirán mi distribución.</li>
</ul>
<p>Esta misma lógica impera para las demás distribuciones notables. Por ejemplo, supongamos que <span class="math inline">\(X \in B(10, 0.1)\)</span> y que nos interesa <span class="math inline">\(P(X=1)\)</span> entonces,</p>
<pre class="r"><code>pbinom(1, 10, 0.1)</code></pre>
<pre><code>## [1] 0.7360989</code></pre>
<p><font color="green"> <em>Los decimales en R se separan con puntos <code>.</code> no con comas <code>,</code>. Si estás acostumbrado a la notación española es común que puedas equivocarte. Tip: En vez de decir “cero coma uno” intenta decir “cero punto uno”, de esta manera evitarás equivocarte cuando estés programando.</em> </font></p>
<p>De manera análoga podemos calcular la función de densidad.</p>
<p>Supongamo que nos interesa p en 1,2,3,4 y 5 y además queremos representarlos gráficamente para nuestra misma <span class="math inline">\(X \in B(10,0.1)\)</span>. Entonces,</p>
<pre class="r"><code>ex &lt;- 0:5
f &lt;- dbinom(ex, 10, 0.1) #En vez de pasarle sólo un número al primer argumento, le pasamos una sentencia. </code></pre>
<p>Hasta aquí tenemos dos objetos: Uno que contiene una secuencia de enteros y otro con nuestra función de probabilidad.</p>
<ul>
<li><code>cbind()</code> Toma vectores, matrices o data frames y los combina en columnas.</li>
</ul>
<p>Vamos a hacer un data frame con los dos y lo representaremos.</p>
<pre class="r"><code>df &lt;- cbind(ex, f)
df</code></pre>
<pre><code>##      ex           f
## [1,]  0 0.348678440
## [2,]  1 0.387420489
## [3,]  2 0.193710244
## [4,]  3 0.057395628
## [5,]  4 0.011160261
## [6,]  5 0.001488035</code></pre>
<ul>
<li><code>plot()</code> Función genérica de graficado base.</li>
</ul>
<pre class="r"><code>plot(df, type = &quot;h&quot;) # El argumento type = &quot;h&quot; nos da líneas verticales. </code></pre>
<p><img src="intro_basica_files/figure-html/unnamed-chunk-121-1.png" width="672" /></p>
<p>Y como sé que la media de la media muestral es la media teórica,</p>
<pre class="r"><code>mean(dbinom(ex, 10, 0.1))</code></pre>
<pre><code>## [1] 0.1666422</code></pre>
<p>Con varianza npq,</p>
<pre class="r"><code>var(dbinom(ex, 10, 0.1))</code></pre>
<pre><code>## [1] 0.02919965</code></pre>
<p>Para las demás distribuciones el los cálculos siguen la misma lógica.</p>
<p><strong>Normal</strong></p>
<ul>
<li><code>pnorm()</code> Probabilidad acumulada.</li>
<li><code>dnorm()</code> Densidad.</li>
<li><code>qnorm()</code> Cuantil.</li>
<li><code>rnorm()</code> Números pseudo-aleatorios que seguirán mi distribución.</li>
</ul>
<p><strong>Poisson</strong></p>
<ul>
<li><code>ppois()</code> Probabilidad acumulada.</li>
<li><code>dpois()</code> Densidad.</li>
<li><code>qpois()</code> Cuantil.</li>
<li><code>rpois()</code> Números pseudo-aleatorios que seguirán mi distribución.</li>
</ul>
<p><strong>…</strong></p>
</div>
<div id="rmarkdown" class="section level2">
<h2>RMarkdown</h2>
<p>Los ejercicios prácticos se presentarán en distintos formatos utilizando RMarkdown. Probablemente una de los mejores manuales por el momento es el de Yihui Xie, J. J. Allaire y Garrett Grolemund que puede consultarse en:</p>
<p><a href="https://bookdown.org/yihui/rmarkdown/" class="uri">https://bookdown.org/yihui/rmarkdown/</a></p>
<p>También existe otro manual realizado por los profesores Fernández-Casal, R. y Cotos-Yáñez, T.R. de la Universidade da Coruña. Puede consultarse en:</p>
<p><a href="https://rubenfcasal.github.io/bookdown_intro/" class="uri">https://rubenfcasal.github.io/bookdown_intro/</a></p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://osl.ull.es/que-es-el-software-libre/" class="uri">https://osl.ull.es/que-es-el-software-libre/</a><a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
